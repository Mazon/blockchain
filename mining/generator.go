package mining

import (
	"blockchain/blockchain"
	"fmt"
	"strings"
	"sync"
)

// NewBlockTemplate returns a new block template that is ready to be solved
// using the transactions from the passed transaction source pool and a coinbase
// that either pays to the passed address if it is not nil, or a coinbase that
// is redeemable by anyone if the passed address is nil.  The nil address
// functionality is useful since there are cases such as the getblocktemplate
// RPC where external mining software is responsible for creating their own
// coinbase which will replace the one generated for the block template.  Thus
// the need to have configured address can be avoided.
//
// The transactions selected and included are prioritized according to several
// factors.  First, each transaction has a priority calculated based on its
// value, age of inputs, and size.  Transactions which consist of larger
// amounts, older inputs, and small sizes have the highest priority.  Second, a
// fee per kilobyte is calculated for each transaction.  Transactions with a
// higher fee per kilobyte are preferred.  Finally, the block generation related
// policy settings are all taken into account.
//
// Transactions which only spend outputs from other transactions already in the
// block chain are immediately added to a priority queue which either
// prioritizes based on the priority (then fee per kilobyte) or the fee per
// kilobyte (then priority) depending on whether or not the BlockPrioritySize
// policy setting allots space for high-priority transactions.  Transactions
// which spend outputs from other transactions in the source pool are added to a
// dependency map so they can be added to the priority queue once the
// transactions they depend on have been included.
//
// Once the high-priority area (if configured) has been filled with
// transactions, or the priority falls below what is considered high-priority,
// the priority queue is updated to prioritize by fees per kilobyte (then
// priority).
//
// When the fees per kilobyte drop below the TxMinFreeFee policy setting, the
// transaction will be skipped unless the BlockMinSize policy setting is
// nonzero, in which case the block will be filled with the low-fee/free
// transactions until the block size reaches that minimum size.
//
// Any transactions which would cause the block to exceed the BlockMaxSize
// policy setting, exceed the maximum allowed signature operations per block, or
// otherwise cause the block to be invalid are skipped.
//
// Given the above, a block generated by this function is of the following form:
//
//   -----------------------------------  --  --
//  |      Coinbase Transaction         |   |   |
//  |-----------------------------------|   |   |
//  |                                   |   |   | ----- policy.BlockPrioritySize
//  |   High-priority Transactions      |   |   |
//  |                                   |   |   |
//  |-----------------------------------|   | --
//  |                                   |   |
//  |                                   |   |
//  |                                   |   |--- policy.BlockMaxSize
//  |  Transactions prioritized by fee  |   |
//  |  until <= policy.TxMinFreeFee     |   |
//  |                                   |   |
//  |                                   |   |
//  |                                   |   |
//  |-----------------------------------|   |
//  |  Low-fee/Non high-priority (free) |   |
//  |  transactions (while block size   |   |
//  |  <= policy.BlockMinSize)          |   |
//   -----------------------------------  --
func (g *BlkTmplGenerator) NewBlockTemplate(payToAddress string) (*BlockTemplate, error) {
	// Extend the most recently known best block.
	best := g.chain.BestSnapshot()
	nextBlockHeight := best.Height + 1
	_ = nextBlockHeight

	// Create a standard coinbase transaction paying to the provided
	// address.  NOTE: The coinbase value will be updated to include the
	// fees from the selected transactions later after they have actually
	// been selected.  It is created here to detect any errors early
	// before potentially doing a lot of work below.  The extra nonce helps
	// ensure the transaction is not a duplicate transaction (paying the
	// same value to the same public key address would otherwise be an
	// identical transaction for block version 1).
	/*extraNonce := uint64(0)
	coinbaseScript, err := standardCoinbaseScript(nextBlockHeight, extraNonce)
	if err != nil {
		return nil, err
	}
	coinbaseTx, err := createCoinbaseTx(g.chainParams, coinbaseScript,
		nextBlockHeight, payToAddress)
	if err != nil {
		return nil, err
	}
	coinbaseSigOpCost := int64(blockchain.CountSigOps(coinbaseTx)) * blockchain.WitnessScaleFactor
	*/
	// Get the current source transactions and create a priority queue to
	// hold the transactions which are ready for inclusion into a block
	// along with some priority related and fee metadata.  Reserve the same
	// number of items that are available for the priority queue.  Also,
	// choose the initial sort order for the priority queue based on whether
	// or not there is an area allocated for high-priority transactions.
	//sourceTxns := g.txSource.MiningDescs()
	//sortedByFee := g.policy.BlockPrioritySize == 0
	//priorityQueue := newTxPriorityQueue(len(sourceTxns), sortedByFee)

	// Create a slice to hold the transactions to be included in the
	// generated block with reserved space.  Also create a utxo view to
	// house all of the input transactions so multiple lookups can be
	// avoided.
	//blockTxns := make([]*btcutil.Tx, 0, len(sourceTxns))
	//blockTxns = append(blockTxns, coinbaseTx)
	//blockUtxos := blockchain.NewUtxoViewpoint()

	// dependers is used to track transactions which depend on another
	// transaction in the source pool.  This, in conjunction with the
	// dependsOn map kept with each dependent transaction helps quickly
	// determine which dependent transactions are now eligible for inclusion
	// in the block once each transaction has been included.
	//dependers := make(map[chainhash.Hash]map[chainhash.Hash]*txPrioItem)

	// Create slices to hold the fees and number of signature operations
	// for each of the selected transactions and add an entry for the
	// coinbase.  This allows the code below to simply append details about
	// a transaction as it is selected for inclusion in the final block.
	// However, since the total fees aren't known yet, use a dummy value for
	// the coinbase fee which will be updated later.
	//txFees := make([]int64, 0, len(sourceTxns))
	//txSigOpCosts := make([]int64, 0, len(sourceTxns))
	//txFees = append(txFees, -1) // Updated once known
	//txSigOpCosts = append(txSigOpCosts, coinbaseSigOpCost)

	//log.Debugf("Considering %d transactions for inclusion to new block")
	fmt.Println("Considering for inclusing in block")
	//len(sourceTxns))

	return &BlockTemplate{
		//Block: &Block,
		//	Fees:              txFees,
		//SigOpCosts:        txSigOpCosts,
		//Height:            nextBlockHeight,
		//ValidPayAddress:   payToAddress != nil,
		//WitnessCommitment: witnessCommitment,
	}, nil
}

// BestSnapshot returns information about the current best chain block and
// related state as of the current point in time using the chain instance
// associated with the block template generator.  The returned state must be
// treated as immutable since it is shared by all callers.
//
// This function is safe for concurrent access.
func (g *BlkTmplGenerator) BestSnapshot() *blockchain.BestState {
	return g.chain.BestSnapshot()
}

//var Blockchain []Block
var height uint32 // height in chain.

var mutex = &sync.Mutex{}

func IsBlockValid(newBlock, oldBlock blockchain.Block) bool {

	return true
}

func isHashValid(hash []byte, difficulty uint32) bool {
	prefix := strings.Repeat("0", int(difficulty))
	return strings.HasPrefix(string(hash[:]), prefix)
}

/*func GenerateBlock(oldBlock Block, tx []transaction.Transaction) Block {
	var newBlock Block

	t := time.Now()

	newBlock.Timestamp = t.String()
	newBlock.Transactions = tx

	// generate block hash of old block header
	oldBlockHash := calculateHash(oldBlock)
	newBlock.PrevHash = oldBlockHash

	newBlock.Difficulty = difficulty

	for i := 0; ; i++ {
		// increase nonce until hash is valid.
		newBlock.Nonce = uint32(i)
		if !isHashValid(calculateHash(newBlock), newBlock.Difficulty) {
			//fmt.Println(calculateHash(newBlock), " do more work!")
			h := calculateHash(newBlock)
			fmt.Println(hex.EncodeToString(h) + " do more work!")
			time.Sleep(time.Second)
			continue
		} else {
			h := calculateHash(newBlock)
			fmt.Println(hex.EncodeToString(h) + "Work done. submit block")
			break
		}

	}
	//fmt.Println(newBlock)
	return newBlock
}*/

//calculates the block header sha256 hash.
/*func calculateHash(block Block) []byte {
	bVersion := util.Uinttobyte(block.Version)
	bNonce := util.Uinttobyte(block.Nonce)
	bDifficulty := util.Uinttobyte(block.Difficulty)

	record := []byte{}
	record = append(record, bVersion[:]...)
	record = append(record, block.PrevHash[:]...)
	record = append(record, bNonce[:]...)
	record = append(record, []byte(block.Timestamp)[:]...)
	record = append(record, bDifficulty[:]...)

	h := sha256.New()
	h.Write([]byte(record))
	hashed := h.Sum(nil)
	//fmt.Println(hex.EncodeToString(hashed))
	return hashed
}*/
